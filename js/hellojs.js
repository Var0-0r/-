// alert("杨霖是猪");


// 运算符 也叫操作符，通过运算符可以对一个或者多个值进行运算，并获取运算结果
    //比如typeof就是一个运算符，可以获得一个值的类型，它会将该值的类型以字符串返回

    //算数运算符
        // 当对非number类型的值进行运算时，他会将这些值转换为number
        // 任何值和NaN做运算都得NaN
    //+两个值相加  true=1 false=0 
        // 如果对两个字符串进行加法运算，则会做拼串，会将两个字符串拼接为一个字符串，并返回
        // 任何的值和字符串做加法运算都会先转换为字符串，然后再做拼串
        // 可以利用这一操作，将任意一个数据类型+一个“”空字符串，将其转换为string类型
        // 这是隐式类型转换，由浏览器完成但是还是用了string（）
    // - 两个值相减，并返回
    // * 两个值相乘
    // / 两个值相除
    // 任何值做-*/都会自动转换为number 隐式类型转换
        // 可以利用 -0 *1 /1 做隐式类型转换
    // %取模运算

    // 一元运算符 只需要一个操作数
    // + 正好 正号对数字不会产生任何影响
    // - 负号 对数字进行取反
    //     对于非number会将其先转换为number在进行运算
    //     可以对其他一个数据类型使用+将其转换为number类型
    //     例如
    //         var a=1+"2"+3;  为string123
    //         var a=1+ +"2"+3; 为number6

    // 自增 通过自增使变量在自身的基础上增加1；
        // 对一个变量自增后，原变量会立即自增一
        // 分为两种a++ ++a；
        // 无论是a++ ++a；都会立即使原变量自增一
        // a++等于的是原变量的值 ++a等于原变量自增后的值
    // 自减 通过自增使变量在自身的基础上减少1；
        // 分为两种a-- --a
        // 无论是a-- --a；都会立即使原变量自减一
        // a--等于的是原变量的值 --a等于原变量自减后的值

    // 逻辑运算符
    //  ！非 对一个布尔值进行取反操作，对非布尔值则会先转换为布尔值，在取反
        // 可以利用其进行其他数据类型转换为布尔值
            // var a="杨霖是猪，再改你就吃粑粑"; a=!!a; //true
    // && 与
        // 可以对符号两侧的值进行与运算，并返回结果 
        // 同真则真，一假则假
            // js中的与属于短路的与，如果第一个值为false则不会执行后面的
            // 对非布尔值则会先转换为布尔值，然后运算，并且返回原值
                // 如果第一个值都为true，则返回后边的值
                // 如果第一个值都为false，则返回前边的值
    // || 或  
        // 可以对符号两侧的值进行或运算，并返回结果 
        // 同假则假，一真则真
            // js中的与属于短路的与，如果第一个值为true则不会执行后面的
            //如果第一个值都为true，则返回第一个值的值
            // 如果第一个值都为false，则返回后边的值

    // 赋值运算
        // = 可以将符号右侧的值赋给左边的变量
        // += a+=5； == a=a+5;
        // -= 同上
        // *= 同上
        // /+ 同上
        // %= 同上
      
    // 关系运算符 
        //  关系成立返回true，不成立返回false
        // > 判断左侧是否大于右侧
        // < 判断右侧是否大于左侧
        // >=判断左侧是否大于等于右侧
        // <=判断右侧是否大于等于左侧
    // 非数值情况
        //  先将其转换为数字在比较
    // 任何值和NaN做任何比较都是false
    // 如果符号两边的值都是字符串，则不会将其转换为数字，而是比较字符串编码
        // 比较字符编码时是一位一位进行比较（用其进行英文排序） 即第一位成立则不会继续比较，对中文没有太大意义
        // 比较两个字符串的数字可能会得到不可预知的结果，所以在比较时需要转型

    //  在js使用转义字符中输出unicode编码
    //  "\ubianma"
    //  在网页中使用转义字符中输出unicode编码
        // &#编码 但是这里注意要使用十进制编码
    
    // 相等运算符==
        // 相等返回true，否则false 
        // 当使用==进行比较时，会进行自动类型转换；一般是转换为数字
        // undefined衍生自unll 所以这两个值做相等运算时，true；
        // NaN不和任何值相等，包括其自身
            // 判断一个值是否为NaN isNaN（）； 是返回true，否则返回false
            // var a=NaN; console.log(isNaN(a));  true

    //不相等运算符！=
        //相等返回false，不相等返回true
        // 不相等也会自动进行类型转换

    // 全等===
        // 判断两个值是否全等 全等返回true，否则false
        // 不会进行自动类型转换

    //不全等！==
        // 判断两个值是否全等 不全等返回ture，否则返回false
        // 不会进行自动类型转换

    // 条件运算符
        //  条件表达式？语句一；语句二；
        //  流程：首先对条件表达式求值，为真执行语句一并返回执行结果，为假执行语句二并返回执行结果
        // 如果条件表达式的值是一个非布尔值，则会将其转换为布尔值，然后再运算
    
    // ， 运算符
        // 分割语句，在声明多个变量时使用
        // var a,b,c;

    // 运算符的优先级
        // 在js中有个运算优先级的表，在表中越靠上，优先级越高
        // 如果优先级一样，则从左往右依次计算 遇到优先级问题,就用()

    // js中使用{}进行分组,同一个{}中的代码要么都执行,要么都不执行
    // 一个{}叫做一个代码块
    // {}只有分组的作用,没有其他的作用 没有作用域?

// 流程控制语句

// prompt() 返回值是string类型 可以弹出一个提示框，该提示框中会带有一个文本框，用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数，该字符串会作为文本框的提示文字
    // 使用
        // var a=prompt("输入你想提示的文字");
        // 想要返回number类型可以写成这样
            // var a=+prompt("输入你想提示的文字");
    // 新的一年希望哥哥万事如意身体健康挣好多好多钱然后都给我
// console.time("计时器名称");
// console.timeEnd("计时器名称");

// 循环
    // 可以为循环创建一个label，来标识当前的循环
    // label:循环语句
    // 使用break语句时，可以在break后跟着一个label
    // 这样break将会结束指定的循环，而不是最近的

// 对象(object)引用数据类型 是一种复合数据类型，在对象中可以保存多个不同数据类型的属性
    // 对象的分类
    // 1.内建对象，由es表标准中定义的对象，在任何的es实现中都可以使用
        // 比如：math、string 
    // 2.宿主对象
        // 由js的运行环境提供的对象，目前来讲主要是由浏览器提供的对象
            // 比如BOM DOM
    // 3.自定义对象
        // 由开发人员自己创建的对象
        // 创建对象
            // 使用new关键字调用的函数是构造函数constructor 构造函数是专门用来创建对象的
            // var obj=new Object();
            // 在对象中保存的值称为属性
            // 向对象中添加属性
                // 语法：对象.属性名=属性值
                // Obj.name="tom";
            // 读取对象中的属性
                // 语法 对象.属性名；
                // 如果读取对象中没有的属性，不会报错而是会返回undefined
                // console.log(obj.name);
            // 修改对象属性值
                // 语法：对象.属性名=新属性值
            // 删除对象的属性
                // 语法:delete 对象.属性名
            // 属性名 尽量按照标识符规范  如果要使用特殊的属性名不能采用.的方式来操作
                // 语法 对象["属性名"]=属性值;
                // 读取方法 console.log(obj["属性名"]);
                // 使用[]这种形式去操作属性,更加的灵活
                // 在[]中可以直接传递一个变量,这样变量值是多少就会读取哪个属性
            // 属性值
                // js对象的属性值,可以是任意的数据类型
                // 甚至可以是一个对象
            // in运算符 
                // 通过该运算符可以检查一个对象中是否含有指定的属性
                    // 有true 无false
                // 语法:"属性名"in对象
// 引用数据类型
    // 基本数据类型 String Number Boolean null undefined
    // JS中变量都是保存在栈内存中的
        // 基本数据类型的值直接在栈内存中存储
        // 值与值之间是独立存在的,修改一个变量不会影响到其他的变量
    // 引用数据类型 Object
        // 对象是保存至对内存的,每创建一个新的对象,就会在堆内存中开辟出一个新的空间
        // 而变量保存的是对象的内存地址(对象的引用),如果两个变量保存的是同一个对象的引用,当一个对象通过一个变量修改属性时,另一个也会受到影响
    // 基本数据类型作比较时,比较的是值
    // 引用数据类型比较时,比较的是内存地址
// 对象字面量
    // 创建对象 var obj={};
    // 可以创建对象时,直接指定对象中的属性
    // 语法: var obj={name:"rr",age=28};
        // 对象字面量的属性名如果起的不符合命名规范需要加""
// 函数 也是一个对象
    // 函数中可以封装功能(代码),必要时可以执行功能
    //  创建一个函数对象
        // 可以将要封装的代码以字符串的形式传递给构造参数
        // 很少使用构造函数来创建
        // var fun=new Function("console.log("hello")");
        // 封装带函数的代码不会立即执行
        // 会在被调用的时候执行
        // 调用函数 语法:函数对象();
        // fun()
    // 使用函数声明创建一个函数
        // 语法:function 函数名([形参1,形参2]){
        //      语句..
        // }
    // 使用函数表达式创建一个函数
        // var fun3=function(){console.log("11")}
// 形参
    // 可以在函数的()中来指定一个或多个形参
    // 多个形参之间用,隔开声明形参就相当于在函数的内声明了对应的变量,但是不赋值
    // 赋值
        // 在调用函数时,可以在()中指定实参,实参会赋值给对应的形参
            // 实参可以是任意的数据类型
        // 调用函数时解析器不会检查实参的类型和数量 多余的形参不会被赋值
            // 如果实参的数量少于形参的数量,则没有对应实参的形参是undefined;
// 返回值
    // 可以使用return来设置函数的返回值
    // 语法: return 值
    // return后的值将会作为函数的执行结果返回,可以定义一个变量接收结果
    // function sum(a,b,c){
    //     var d = a+b+c;
    //     return d;
    // }
    // var result=sum(1,2,3);
    // return后的语句不会被执行
    // 如果return语句后不跟任何值或者函数中没有return就相当于返回一个undefined
// 实参可以是任何值
    // mianji()
        // 调用函数 相当于使用函数的返回值
    // mianji
        // 函数对象 相当于直接使用函数对象
// 立即执行函数
    // (function(){
    //     alert("我是匿名函数,我被立即执行了");
    // })();
    // 特点:一般只会执行一次
// 立即执行函数
// (function(){
//     alert("我是匿名函数,我被立即执行了");
// })();
// 特点:一般只会执行一次
// 函数也可以成为对象的属性,如果一个函数作为一个对象的属性保存,那么我们成这个函数是这个对象的方法,调用这个函数就说调用对象的方法
// var obj = { name: "rr", age: 12 }
// obj.sayName = function () {
//     console.log(obj.name);
// }
// // 调用方法
// obj.sayName();
// function fun() {
//     console.log(obj.sayName);
// }
// // 调用函数
// fun();
//枚举对象中的属性
// 使用for.. in语句在对象中有几个属性,循环就会执行几次
// 每次执行时,会将对象中的一个属性的名字赋值给变量
// for (var n in document) {
//     console.log("属性值" + obj[n]);
// }
// 作用域 指一个变量的作用范围
// js中一共有两种作用域
    // 1.全局作用域
        // 直接编写在script标签中的js代码,都是全局作用域;
        // 全局作用域在页面打开时创建,在页面关闭时销毁
        // 在全局作用域中有一个全局对象window,可以直接使用
            // window代表的是一个浏览器的窗口, 它由浏览器创建
        // 在全局作用域中,创建的对象都是会作为window对象的属性保存
            // var a=10; console.log(window.a);
        // 创建的函数都会作为window的方法
        // 变量的声明提前
            // 使用var关键字声明的变量,会在所有代码执行之前被声明
            // 但是如果声明变量时不使用var关键字,则变量不会被提前声明
        // 函数的声明提前
            // 使用函数声明形式创建的函数function 函数名(){}
                // 它会在所有代码执行之前就被创建,所以我们可以在函数声明前就调用函数
            // 使用函数表达式创建的函数var fun=functionion(){},不会被声明提前,所以不能在声明前调用
    // 2.函数作用域
        // 调用函数时创建,函数执行完毕后,函数作用域销毁
        // 每调用一次函数作用域就会创建一个新的函数作用域,他们之间相互独立
        // 在函数作用域中能访问到全局变量,在全局作用域中,无法访问函数作用域
        // 当在函数作用域操作一个变量是,它会先在自身作用域中寻找;没有就向上一级寻找,直到全局作用域
            // 如果全局作用域还没有,报错undefined
        // 在函数中想访问全局变量可以加window
        // 函数作用域遵循变量和函数声明提前的特性
        // 在函数中,不使用var声明的变量都会成为全局变量

// debug
// this 
    // 解析器在调用函数时每次都会向函数内部传递一个隐含的参数，这个隐含的参数就是this，this指向是一个对象
        // 这个对象我们称为函数执行的上下文对象，根据函数的调用方式的不同，this会指向不同的对象
        // 1.以函数的形式调用时，this永远都是window
        // 2.以方法的形式调用时，this就是调用方法的对象
        // 3.当以构造函数的形式调用时,this就是新创建的那个对象
        // 4.使用call和apply调用时，this是指定的那个对象
        // 5.在事件的响应函数中，响应函数是谁给谁绑定的this就是谁
// 使用工厂法创造对象 使用该方法可以大批量创建对象
    // function creatPerson(name,age,gender){
    //     // 创建一个对象
    //     var obj=new Object();
    //     // 向对象添加属性
    //     obj.name=name;
    //     obj.age=age;
    //     obj.gender=gender;
    //     obj.sayName=function(){
    //         alert(this.name);
    //     }
            // return obj
    // }
    // var obj2=new  creatPerson("rr",16,"女");
    // obj2.sayName();    
    // 使用工厂法创建的对象,使用的构造函数都是object,所以创建的对象都是object这个类型,就导致我们无法区分出多种不同类型的对象
// 构造函数
    // 构造函数就是一个普通的函数,创建方式和普通函数没有区别
    // 不同的是构造函数习惯性首字母大写
    // 构造函数和普通的函数调用方式不同,普通函数是直接调用,构造函数使用new关键字来调用
    // 构造函数的执行流程
        // 1.立刻创建一个新的对象
        // 2.将新建的对象设置为函数中的this,再构造函数中可以使用this来引用新建的对象
        // 3.逐行执行函数中的代码
        // 4.将新建的对象作为返回值返回
    // 使用同一个构造函数创建的对象,我们称为一类对象,也将一个构造函数称为一个类
        // 我们将通过一个构造函数创建的对象,称为是该类的实例
    // function Person(name,age){
    //     this.name=name;
    //     this.age=age;
    //     this.sayName=function(){
    //         alert("this.name");
    //     }
    // }
    // var per=new Person("rr",16);
    // 使用instanceof可以检查一个对象是否是一个类的实例
    // 语法: 对象 instanof 构造函数
        // 如果是返回true,否则返回false
    // console.log(per instanceof Person);
    // 所有的对象都是object的后代
        // 所以任何对象和object做instanceof检查时都会返回true

    // 上述创建的Person类中添加了一个sayName方法,由于是在内部创建,该构造函数每执行一次就会创建一个新的sayName方法
        // 会造成极大的资源浪费  可以做如下更改
        // function Person(name,age){
            //     this.name=name;
            //     this.age=age;
                // this.sayName=fun; 
            // }
            // 这样是将函数定义在全局作用域,会污染全局作用域的命名空间,也很不安全
            // function fun (){
                //         alert("this.name");
                //     }
            // var per=new Person("rr",16);
// 原型 prototype
    // 我们所创建的每一个函数,解析器都会向函数中添加一个属性prototype
    // 这个属性对应着一个对象,这个对象就是我们所谓的原型对象
    // 如果函数作为普通函数调用prototype没有任何作用
    // 当函数以构造函数的形式调用时,它所创建的对象中都会有一个隐含的属性,指向该构造函数的原型对象,我们可以通过__proto__来访问该属性
    // 原型对象就相当于一个公共的区域,所有同一个类的实例都可以访问到这个原型对象,
        // 我们可以将对象中的共有的内容,统一设置到原型对象中
    // 当我们访问对象的一个属性或方法时,他们会先在对象自身中寻找,如果有直接使用,如果没有则会去原型对象中寻找,如果找到就使用
        // 如果还没有就去原型的原型中寻找,直到找到object的原型
            // Object对象的原型没有原型,如果在object中依然没有找到,则返回undefined
    // 根据原型继续优化      
    //function Person(name,age){
        //     this.name=name;
        //     this.age=age;
        // }
        // Person.prototype.sayName(){
        //     alert("你好");
        // }
        // var per=new Person("rr",16);
        // 以后我们创建构造函数时,可以将这些对象共有属性和方法统一添加到函数的原型对象中,
            // 这样不用分别为每一个对象添加,也不会影响到全局作用域,就可以使每个对象都具有这些属性和方法了
    //创建一个构造函数
    // function Fun(){}
    //向构造函数的原型中添加属性
    // Fun.prototype.name="rr";
    // var mc=new Fun();
    //使用in检查对象中是否有nameshuxing
    // console.log("name" in mc);
    //返回true 对象中虽然没有但是原型中有也会返回true;
    // 在这样的情况下可以使用hasOwnProperty()来检查对象自身中是否含有该属性
        // 该方法只有在自身含有该属性时才会返回true,否则返回false
    // console.log(mc.hasOwnProperty("name"));
// tostring
    // 当我们直接在页面中打印一个对象时,实际上是输出的对象的toString()方法的返回值
    // 如果我们希望在输出对象时不输出[object obje],可以为对象添加一个toString()方法
    // function Person(name,age){
        // this.name=name;
        // this.age=age;
    // }
    // Person.prototype.toString=function(){
        // return "Person名字是"+this.name+"年龄是"+this.age;
    // }
    // var per =new Person("rr",18);
// 垃圾回收(GC)
    // 程序运行过程中会产生垃圾,这些垃圾过多以后,会导致程序运行速度缓慢
        // 所以我们需要垃圾回收机制,来处理程序运行产生的垃圾
    // 当一个对象没有任何的变量或属性对他进行引用,此时我们将永远无法操作该对象,此时这种对象就是一个垃圾,这种对象
        // 过多会占用大量的内存空间,导致程序运行变慢,所以这种垃圾必须清理
    // 在js中有自动的垃圾回收机制,会自动将这些垃圾对象从内存中销毁
        // 我们不需要也不能进行垃圾回收操作
    // var obj=new Object(); obj=null;
    //我们需要做的就是将不再使用的对象设置为null即可
// 数组 Array 他也是对象,和普通对象相似,存储一些值
    // 不同的是普通对象是使用字符串作为属性名的,而数组使用数字作为索引(index)元素
    // 索引 从0开始的整数
    // 数组的存储性能比普通对象好,在开发中我们经常使用数组来存储一些数据

    // 创建数组对象
    // var arr=new Array();
    //向数组添加元素
        // 语法:数组[索引]=值;
    // arr[0]=10;
    //读取数组中的元素
        // 语法:数组[索引]
        // 如果读取不存在的数组,不会报错而是会返回undefined
        //输出指定索引的值
    // console.log(arr[0]);  
        //输出数组所有的值
    // console.log(arr);
    //获取数组的长度
        //可以使用length属性获取数组长度(元素的个数)
        // 语法:数组.length
            // 对于连续的数组,可以获得长度  对于非连续的数组,会返回数组最大的索引+1
                // 尽量不要创建非连续的数组
    // console.log(arr.length);
    //修改length
        // 如果修改的length大于原长度,则多出部分会空出来
        // 如果修改的length小于原长度,则多出部分会被删除
    // arr.length=10;
    //向数组最后一个位置添加元素
    // arr[arr.length]=2;
    //使用字面量创建数组
        // 语法:[]
    // var aarr=[];
    //使用字面量创建数组,可以在创建时就指定数组中的元素
    // var aaarr=[1,2,3];
    //使用构建函数创建数组,也可以同时添加元素,将要添加的元素作为构造函数的参数传递;元素之间用,分开
    // var ary=new Array(1,2,3);
    //创建一个数组,数组中只有一个元素10
    // arr=[10];
    //创建一个数组,数组长度为10
    // arr2=new Array(10);
    // 数组中的元素可以是任意的数据类型
    // arr =["hello",1,true]
    // 也可以是对象
    // arr=[{name:"rr"},{name:yl}];
    // alert(arr[1].name);
    //也可以是个函数
    // arr=[function(){}]
    // arr[0]();
    //也可以是数组  如下称为二维数组
    // arr=[[1,2,3],[2,3,4]]
    // alert(arr[0]);
    // 数组的方法
        // var arr=["rr","yl"];
        // push()
            // 该方法可以向数组的默哀未添加一个或者多个元素,并返回数组新的的长度
                // 可以将要添加的元素作为方法的参数传递
                // 这样这些元素将会自动添加到数组的末尾
        // var re=arr.push("rl","lr");
        // re会返回新的数组的长度
        // pop()
            // 该方法可以删除数组的最后一个元素
        // var rr=arr.pop();
        // rr会返回被删除的元素
        // unshift() 
            //向数组的开头添加一个或多个元素,并返回新的数组的长度,向前边添加元素后,其他的元素索引会依次向后调整
        // var ar=arr.unshift("rrr","yyy");
        // ar会返回新的数组的长度
        // shift()
            // 删除数组的第一个元素会返回被删除的元素(arrr)
        // var arrr=arr.shift();
    // 数组的遍历
        // 遍历数组就是将数组中所有元素都取出来
    // for(var i=0;i<arr.length;i++){
    //     console.log(arr[i]);
    // }
    // forEach()
        // JS中为我们提供的遍历数组的方法 ie8以上才支持
    // var arr=["rr","yl"];
    // forEach() 需要一个函数作为参数  这种由我们创建但是不是由我们调用的函数称为回调函数
        // 数组中有多少个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参，来读取这些内容
        // 浏览器会在回调函数中传递三个参数
            // 第一个参数 是当前正在遍历的元素
            // 第二个参数，是当前正在遍历的元素的索引
            // 第三个参数 是当前正在遍历的数组
    // arr.forEach(function(value,index,arr){});
    // slice()
        // 从某个数组中提取指定元素 但是该方法不会改变数组，而是将截取到的元素封装到一个新的数组返回
            // 参数：1.截取开始的位置的索引,包含开始
                // 2.截取结束的位置的索引,不包含结束 第二个参数可以省略，这样就会截取从开始索引以后的所有值
                    // 索引可以传递一个负值，代表从后往前计算 -1倒数第一个...
        // var arr=["rr","yl","rl"];
        // var result=arr.slice(0,2);
        // alert(result);
    // spalice 删除数组中的指定元素 使用spalice（）会影响到原数组，会将指定元素从原数组删除，并将被删除的元素作为返回值返回
            // 参数 1.第一个表示开始位置的索引
                // 2.第二个表示删除的数量
                // 3.第三个及以后 代表可以传递一些新的元素，这些元素将自动插入到开始位置的索引
        // var result= arr.splice(0,2); 
        // result将返回被删除的元素
        // var ary = [1, 2, 3, 1, 2, 4, 3, 4, 5];
        // for (var i = 0; i < ary.length; i++) {
        //     for (var j = i + 1; j < ary.length; j++) {
        //         if (ary[i] == ary[j]) {
        //             ary.splice(j, 1)
        //             j--;
        //         }
        //     }
        // }
        // console.log(ary);
    // concat() 可以连接两个或多个数组，并将新的数组返回
        // 该方法不会影响原数组
        // var arr=["rr"];
        // var arr2=["ll"];
        // var result=arr.concat(arr2，arr3,"rl");
        // result返回"rr,ll"
    // join() 该方法可以将数组转换为一个字符串
        // 不会对原数组产生影响，而是将转换后的字符串作为结果返回
        // 在join（）中可以指定一个字符串作为参数，这个字符串将会成为数组中的元素的连接符
            // 如果不指定连接符，则默认使用，连接
        // var arr=["rr","ll"];
        // result=arr.join("--");
        // result返回rr--ll
    // reverse（） 该方法用来反转数组（前边去后边，后边来前边） 会直接修改数组
        // arr=["rr","ll"];
        // arr.reverse();
    // sort（） 可以用来对数组中的元素进行排序 会直接影响数组，默认按照Unicode编码排序,所以对数字进行排序时，可能会得到错误的结果
        // 我们可以自己指定排序的规则，在回调函数中定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数 使用哪个元素不确定名单上肯定的是数组a一定在b前
        // 浏览器会根据回调函数的返回值俩觉得元素的顺序，如果返回一个大于0的值，则元素会交换位置，小于0，位置不变，等于0，认为其相等，不交换位置
            // 如果需要升序排列，则返回a-b，降序排列返回b-a
        // arr=[a,b,c,e,f];
        // arr.sort(function(a,b){
            // 升序排列
            // return a-b;
            // 降序排列
            // return b-a;
        // });
// 补充函数对象的方法
    // call（）和apply()
        // 这两个方法都是函数对象的方法，需要通过函数对象来调用
        // 当对函数调用call（）和apply（）都会调用函数执行
        // 在调用call（）和apply（）可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的this
        // call（）方法可以将实参在对象之后依次传递
        // apply（）/方法需要将实参封装到一个数组中统一传递
// 在调用函数时，浏览器每次都会传递两个隐含的参数
    // 1.函数的上下文对象this
    // 2.封装实参的对象arguments
        // arguments是一个类数组对象，它也可以通过索引来操作数据，也可以获取长度
        // 在调用函数时，我们所传递的实参都会在arguments中保存
        // arguments.length可以用来获取实参的长度
        // 我们即使不定义形参，也可以通过arguments来使用实参
            // 只不过比较麻烦
            // arguments[0]表示第一个实参
            // arguments[1]表示第二个实参
        // arguments有一个属性叫callee 这个属性对应一个函数对象，就是当前正在指向函数的对象 
// data对象 在js中使用其表示一个时间
    // 如果直接使用构造函数创建一个date对象，则会封装为当前代码的执行时间
    // var d=new Date();
    // console.log(d);
    //创建一个指定的事件对象
    //需要在构造参数中传递一个表示时间的字符串作为参数
    // 日期格式 月份/日/年 时：分：秒
    // var d2=new Date("12/03/2022 24:00:00");
    // getDate()
        // 获取当前日期对象是几日
    // getDay（）
        // 获取当前日期对象是周几 会返回一个0-6的值 0表示周日
    // getMonth()
        // 获取当前日期对象是几月 0表示1月
    // getFullYear（）
        // 获取当前日期对象的年份
    // getTime()
        // 获取当前日期对象的时间戳  时间戳，指的是从格林威治标准时间到对象日期的毫秒数（1秒=1000毫秒）
        // 计算机底层在保存时间时使用的都是时间戳
    // 获取当前的时间戳
        // Date.now  time=Date.now();
// Math 和其他的对象不同，他不是一个构造函数，它属于一个工具类不用创建对象，里面封装了数学运算的相关属性和方法
    // Math.PI 圆周率
    // abs（） 计算一个数的绝对值
    // Math.ceil() 对一个数进行向上取整
    // Math.floor() 对一个数进行向下取整
    // Math.round() 四舍五入取整
    // Math.random() 可以生成0-1之间的随机数
        // 生成一个0-x的随机整数
    // console.log(Math.round(Math.random()*x));
        // 生成一个1-10的随机整数
    // console.log(Math.round(Math.random()*9)+1);
        // 生成一个x-y的随机整数
    // Math.round(Math.random()*(y-x))+x;
    // max() 可以获取多个数中的最大值
    // min（）可以获取多个数中的最小值
    // pow（）返回x的y次方
        // console.log(Math.pow(2,3));
    // sqrt() 开根号
        // console.log(Math.sqrt(9));
//包装类
    // js中为我们提供了三个包装类，可以通过这三个包装类可以将基本的数据类型转换为对象,实际开发不用
    // String（）可以将基本数据类型字符串转换为String对象
        // var str =new String("rr");
    // Number（）可以将基本数据类型数字转换为Number对象
        // var num=new Number(12);
    // Boolean（）可以将基本数据类型布尔值转换为Boolean对象
        // var bool = new Boolean(false);
    // 当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性和方法
        // 调用完以后，再将其转换为基本数据类型 
//String 方法
    // 在底层字符串是以字符数组的形式保存的
    // 所以适应部分数字方法
    var str="rrshibendan";
    // console.log(str.length);  
    // console.log(str[0]);
    // charAt（）
        // 可以返回字符串中指定位置的字符，根据索引获取指定的字符
        // var result=str.charAt(0);
        // result会返回第一个字符
    // charCodeAt（）
        // 获取指定位置的字符的字符编码
    //formCharCode（）可以根据字符编码去获取字符
        // var result=String.fromCharCode(72);
        // result返回H
    // concat()
        // 可以连接两个或多个字符串  作用和+类似
    // indexOf
        // 该方法可以检索一个字符串是否含有指定内容
            // 如果字符串含义该内容，则会返回其第一次出现的索引,若果没有指定的内容返回-1
            // 可以指定第二个参数，表示指定开始查找的位置
        // var result=str.indexOf("r");
    // lastIndexOf()
        // 该方法可以检索一个字符串是否含有指定内容
            // 如果字符串含义该内容，则会返回其最后一次次出现的索引
            // 可以指定第二个参数，表示指定开始查找的位置
    // slice()
        // 可以从字符串中截取指定的内容
        // 不会影响原字符串，而是将截取的内容返回        
        // result=str.slice(0,2);  
        // 1.截取开始的位置的索引,包含开始
        // 2.截取结束的位置的索引,不包含结束 第二个参数可以省略，这样就会截取从开始索引以后的所有值
            // 索引可以传递一个负值，代表从后往前计算 -1倒数第一个...
    // substring（）
        // 同上
        // 不同的是，这个方法不能接收负值，如果传递了一个负值，会默认使用0
        // 而且如果第二个参数小于第一个，会自动交换参数位置
    // substr()
        // 用来截取字符串
            // 第一个参数：截取开始位置的索引 第二个参数，截取的长度
    // split()
        // 可以将一个字符串拆分为一个数组
        // 参数：需要一个字符串作为参数，将会根据字符串去拆分数组
            // 如果传递一个空串，则会将每个字符都拆分成数组的一个元素
        // var str="abc,efg";
        // result=str.split(",");
    // toUpperCase()
        // 将一个字符串转换为大写
        // result=str.toUpperCase()
    // toLowerCase()
        // 将一个字符串转换为小写
        // result=str.toLowerCase();
// 正则表达式
    // 用于定义字符串规则，计算机可以根据其判断是否符合规则
        // 或将字符串中符合规则的内容提取出来
    // 创建正则表达式对象
    // 语法：var 变量=new RegExp("正则表达式","匹配模式");
        // var reg=new RegExp("a");这个正则表达式可以来检查一个字符串中是否含有a
        // 第二个参数匹配模式
            // i 忽略大小写
            // g 全局匹配模式
    // var reg=new RegExp("a","i");
        
    // 正则表达式方法
    // test()
        // 使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合返回true否则返回false
    // 使用字面量创建正则表达式 这种简单，构造函数比较灵活
        // 语法：var 变量 =/正则表达式/匹配模式
        var reg=/a/i;
    // 创建一个正则表达式，检查一个字符串是否含有a或b
        // 使用|表示或者的意思
        var reg=/a|b/i;
    // 创建一个正则表达式，检查一个字符串是否含有字母
        // []里面也是或的关系
        // [ab]表示a|b
        // [a-z]任意小写字母
        // [A-Z]任意大写字母
        // [A-z]任意字母
        // [0-9]任意数字
        // reg=/[]/
    // 检查一个字符串是否含有abc或adc或aec
        // reg=/a[bde]c/ 
    // 除xx以外
        // [^xx]
// 字符串和正则表达式相关的方法
    // split()
    // 可以将一个字符串拆分为一个数组
        // 方法中可以传递一个正则表达式作为参数，这样方法会根据正则表达式去拆分字符串
        // 这个方法会默认全局匹配
    // search（）
        // 可以搜索字符串是否含有指定内容
            // 如果存在返回第一次出现的索引，如果没搜索到-1
        // 方法中可以传递一个正则表达式作为参数，这样方法会根据正则表达式去检索字符串
        // 他不能设置全局匹配
    // match（）
        // 可以根据正则表达式，从一个字符串中将符合条件的内容提取出来
        // 默认情况下match只会寻找第一个符合要求的内容，找到后就会停止检索
            // 可以设置正则表达式为全局匹配模式，这样就会匹配所有的内容
        // 可以为一个正则表达式设置多个匹配模式，且顺序无所谓
        // match会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果
    // replace（）
        // 可以将字符串中指定内容替换为新的内容
        // 参数1.被替换的内容，可以是一个正则表达式2新的内容
        // 默认只替换第一个
// 正则表达式语法   
    // 量词
        // 通过量词可以设置一个内容出现的次数
        // 量词只对他前边的一个内容起作用
        // {n}正好出现n次   
        // 可以用()表示一个内容                                            
        // {m,n} 出现m-n次
        // {m,}m次以上
        // +至少一个相当于{1,}
        // *0个或多个
        // ?0个或1个
        // ^a检查一个字符串是否以a开头
        // a$检查一个字符串是否以a结尾
        // 如果在正则表达式中同时使用^和$则要求字符串必须完全符合正则表达式
    // 手机号规则
    // 以1开头第二位3-9之间后面任意数字9个
        // /^1[3-9][0-9]{9}$/
        // .表示任意字符
        // \.检查受含有.
        //\\表示一个\
        // 注意使用构造函数时,由于它的参数是一个字符串,而\是字符串中的转义符
            // 如果要使用\则需要使用\\代替
        //\w 任意字母数字下划线
        //\W除了字母数字下划线
        //\d 任意数字
        //\D 除了数字
        //\s 空格
        //\S 除了空格
        //\b 单词边界
        //\B 除了单词边界
            // 单词边界 表示一个独立的单词
        // 去除字符串空格
        // var str="   hello   ";
        // str = str.replace(/\s/g,"");
        // 去除字符串前后的空格
        // var str="   hello   ";
        // str = str.replace(/^\s*|\s*$/g,"");
        // 电子邮件格式
            // 开头任意字母数字下划线
            // 然后.人一些数字字母下划线
            // @
            // 任意字母数字
            // .任意字母(2-5位) 
            // \^w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$\



    
    

    

