1.JavaScipt包含 ECMASript（标准） Dom（文档对象模型） Bom（浏览器对象模型）
2.js特点 解释型语言 类似c和java的语法结构 动态语言 基于原型的面向对象
<!-- 标签内js代码可以写，但是属于结构与行为耦合，不方便维护，不推荐使用 -->
    <!-- 可以写在标签的onclick属性中，点击执行js代码 -->
    <button onclick="alert('杨霖是猪');">点</button>
    <!-- 可以写在a标签的href中，点击a标签执行js代码 -->
    <a href="javascript:alert('杨霖是猪');">点我</a>
    <!-- <a href=""></a> -->
<!-- 外部引入js代码 -->
    <!-- <script></script> 一旦用来引入外部标签，就不能在编写代码了，浏览器会忽略
    如果需要可以再写一个script标签-->
    <script src="hellojs.js"></script>
    <!-- <script>

        //  浏览器弹出警告框
        // alert("hello JS");
        // 让计算机在页面输出内容
        // document.write("hello JS"); 可以向body中输出内容
        // 控制台输出内容
        // console.log("控制台输出");
        // 从上到下依次执行
    </script> -->
基本语法
// 注释
        // 1.js严格区分大小来写
        // 2.js中每一条语句以；结尾
            // 如果不写分号，浏览器会自动添加，但是会消耗系统资源，而且有时候，浏览器会嘉措分号，所以必须写
        // 3.js会忽略多个空格和换行，所以我们可以利用空格和换行进行代码格式化


        // 字面量和变量
        // 字面量都是一些不可以改变的值 比如12345
            // 字面量都是可以直接使用的，但是我们一般不会直接使用字面量
        // 变量 变量可以用来保存字面量，变量的值可以任意改变，更加方便使用，所以开发中都是使用变量来保存字面量
        // 可以通过变量对字面量进行描述
        // 声明变量
            // js中使用var关键字来声明变量
            // var a;
            // a=123;
            // 或者
            // var b = 234;
            // alert(a);
// 标识符
            // 在js中所有的可以我们自主命名的都可以称为是标识符
            // 例如变量名、属性名、函数名
            // 规则：标识符中可以包含 字母\数字\下划线\$ 
                    // 标识符不能以数字开头
                    // 标识符不能是es中的关键字和保留字
                    // 标识符一般采用驼峰命名法 首字母小写，每个单词的开头字母大写，其余字母小写 xxYyZz
                // JS底层保存标识符实际上是采用的Unicode编码，所以理论上讲，所有的utf-8中含有的内容都可以作为标识符

// 数据类型
                // 数据类型指的就是字面量的类型
                // js中有六种
                //     String 字符串
                //     Number 数值
                //     Boolean 布尔值
                //     Null 空值
                //     undefined 未定义
                //     Object 对象
                // 其中string、number、boolean、null、undefined属于基本数据类型
                // object属于引用数据类型
                // string字符串 js中需要使用引号引起来 双引号单引号都可以，但是不要混着用
                //             引号不能嵌套 双引号里面不能放双引号，单引号里面不能放单引号；
                //                 但是可以这样 var str = '"你好"';
                //                 或者可以使用\作为转义字符 var str = "\"你好\"";
                //                 \n：换行 \t:制表符 \\:\  
                // var str = "hello";
                // console.log("str");
                // Number 数值
                // 在js中所有的数值都是number类型
                //     包括整数和浮点数
                // var a=123;
                // console.log(a);
                // 运算符typeof 检查变量类型；
                //     console.log(typeof a);
                // JS中最大的数 Number.MAX_VALUE
                // JS中最小的数 Number.MIN_VALUE
                //     console.log(Number.MAX_VALUE);
                // 如果使用number表示的数字超过了最大值，则会返回一个Infinity（字面量 数值类型） 表示正无穷
                // NaN not a number 
                // 整数运算基本可以保证精度，如果使用其进行浮点数运算，可能得到一个不精确的值，所以不要使用其进行精确度高的运算
                // Boolean 布尔值 主要用来逻辑判断
                    // 布尔值只有两个 真true 假false
                    // var bool=true;
                    // console.log(bool);
                // Null 空值
                //     null的值只有一个就是null，专门用来表示空对象
                //     console.log(typeof null); 返回object
                // // Undefined 未定义 
                //     undefined只有一个值undefined
                //     当声明一个变量但是并不赋值时，它的值就是undefined；
                //         var a=undefined; console.log(typeof a); undefined
//强制类型转换
         指将一个数据类型强制转换为其他的数据类型
         主要指，将其他数据类型转化为string Number Boolean
        1.将其他数据类型转化为string
             1）调用被转换数据类型的toString()方法；  null和undefined没有tostring，调用会报错;
                 该方法不会影响到原变量，它会将转换的结果返回;
             var a=123;
             var b=a.toString();  或者 a=a.toString();
             console.log(typeof b);  console.log(typeof a);
             2).调用string（）函数 使用string（）方法进行强制类型转换时，对于number和Boolean实际上就是调用了同string（）方法；
                 对于null和undefined，mull直接转换为“null”；undefined转换为“undefined”
             var a=123; a=String(a); console.log(typeof a);
        2.将其他数据类型转化为number
             1）使用number函数  
                 字符串转换为数字
                     如果是纯数字的字符串将其直接转换为数字
                     如果其中有非数字的内容，转换为NaN
                     如果字符串为空或者全是空格则转换为0
                 布尔转数字
                     true转化为1 false转换为0
                 null转数字为0
                 undefined转数字为0
             var a= "123"; a=Number(a); console.log(typeof a);
             2）专门处理字符串 parseInt（） parseFloat()
             parseInt（） 可以将一个字符串中的有效整数内容取出来，然后转换为number int；
             var a= "123px"; a=parseInt(a); console.log(typeof a);
             parseFloat()和parseInt()一样，它可以获得有效的小数；          
            如果对于非String使用parseInt（） parseFloat()，它会先将其转换为string在转换为number
        3.将其他数据类型转化为Boolean
                //使用boolean()函数  
                // 数字转Boolean
                //     除了0和NaN都是true
                // String转Boolean
                //     除了''都是true
                // null和undefined转Boolean都是false
                // 对象也会转换为true
//             var a= 123; a=Boolean(a); console.log(typeof a);

//其他进制数字
        // 16进制0x； 0x10
        // 8进制 0    070  有些浏览器会将其当成八进制，有些当成十进制解析
        //         解决 a='070' a=parseInt(a,10);或a=parseInt(a,8);
        // 2进制 0b 

// 运算符 也叫操作符，通过运算符可以对一个或者多个值进行运算，并获取运算结果
    //比如typeof就是一个运算符，可以获得一个值的类型，它会将该值的类型以字符串返回

    //算数运算符
        // 当对非number类型的值进行运算时，他会将这些值转换为number
        // 任何值和NaN做运算都得NaN
    //+两个值相加  true=1 false=0 
        // 如果对两个字符串进行加法运算，则会做拼串，会将两个字符串拼接为一个字符串，并返回
        // 任何的值和字符串做加法运算都会先转换为字符串，然后再做拼串
        // 可以利用这一操作，将任意一个数据类型+一个“”空字符串，将其转换为string类型
        // 这是隐式类型转换，由浏览器完成但是还是用了string（）
    // - 两个值相减，并返回
    // * 两个值相乘
    // / 两个值相除
    // 任何值做-*/都会自动转换为number 隐式类型转换
        // 可以利用 -0 *1 /1 做隐式类型转换
    // %取模运算

    // 一元运算符 只需要一个操作数
    // + 正好 正号对数字不会产生任何影响
    // - 负号 对数字进行取反
    //     对于非number会将其先转换为number在进行运算
    //     可以对其他一个数据类型使用+将其转换为number类型
    //     例如
    //         var a=1+"2"+3;  为string123
    //         var a=1+ +"2"+3; 为number6

    // 自增 通过自增使变量在自身的基础上增加1；
        // 对一个变量自增后，原变量会立即自增一
        // 分为两种a++ ++a；
        // 无论是a++ ++a；都会立即使原变量自增一
        // a++等于的是原变量的值 ++a等于原变量自增后的值
    // 自减 通过自增使变量在自身的基础上减少1；
        // 分为两种a-- --a
        // 无论是a-- --a；都会立即使原变量自减一
        // a--等于的是原变量的值 --a等于原变量自减后的值

    // 逻辑运算符
    //  ！非 对一个布尔值进行取反操作，对非布尔值则会先转换为布尔值，在取反
        // 可以利用其进行其他数据类型转换为布尔值
            // var a="杨霖是猪，再改你就吃粑粑"; a=!!a; //true
    // && 与
        // 可以对符号两侧的值进行与运算，并返回结果 
        // 同真则真，一假则假
            // js中的与属于短路的与，如果第一个值为false则不会执行后面的
            // 对非布尔值则会先转换为布尔值，然后运算，并且返回原值
                // 如果第一个值都为true，则返回后边的值
                // 如果第一个值都为false，则返回前边的值
    // || 或  
        // 可以对符号两侧的值进行或运算，并返回结果 
        // 同假则假，一真则真
            // js中的与属于短路的与，如果第一个值为true则不会执行后面的
            //如果第一个值都为true，则返回第一个值的值
            // 如果第一个值都为false，则返回后边的值

    // 赋值运算
        // = 可以将符号右侧的值赋给左边的变量
        // += a+=5； == a=a+5;
        // -= 同上
        // *= 同上
        // /+ 同上
        // %= 同上
      
    // 关系运算符 
        //  关系成立返回true，不成立返回false
        // > 判断左侧是否大于右侧
        // < 判断右侧是否大于左侧
        // >=判断左侧是否大于等于右侧
        // <=判断右侧是否大于等于左侧
    // 非数值情况
        //  先将其转换为数字在比较
    // 任何值和NaN做任何比较都是false
    // 如果符号两边的值都是字符串，则不会将其转换为数字，而是比较字符串编码
        // 比较字符编码时是一位一位进行比较（用其进行英文排序） 即第一位成立则不会继续比较，对中文没有太大意义
        // 比较两个字符串的数字可能会得到不可预知的结果，所以在比较时需要转型

    //  在js使用转义字符中输出unicode编码
    //  "\ubianma"
    //  在网页中使用转义字符中输出unicode编码
        // &#编码 但是这里注意要使用十进制编码
    
    // 相等运算符==
        // 相等返回true，否则false 
        // 当使用==进行比较时，会进行自动类型转换；一般是转换为数字
        // undefined衍生自unll 所以这两个值做相等运算时，true；
        // NaN不和任何值相等，包括其自身
            // 判断一个值是否为NaN isNaN（）； 是返回true，否则返回false
            // var a=NaN; console.log(isNaN(a));  true

    //不相等运算符！=
        //相等返回false，不相等返回true
        // 不相等也会自动进行类型转换

    // 全等===
        // 判断两个值是否全等 全等返回true，否则false
        // 不会进行自动类型转换

    //不全等！==
        // 判断两个值是否全等 不全等返回ture，否则返回false
        // 不会进行自动类型转换

    // 条件运算符
        //  条件表达式？语句一；语句二；
        //  流程：首先对条件表达式求值，为真执行语句一并返回执行结果，为假执行语句二并返回执行结果
        // 如果条件表达式的值是一个非布尔值，则会将其转换为布尔值，然后再运算
    
    // ， 运算符
        // 分割语句，在声明多个变量时使用
        // var a,b,c;

    // 运算符的优先级
        // 在js中有个运算优先级的表，在表中越靠上，优先级越高
        // 如果优先级一样，则从左往右依次计算 遇到优先级问题,就用()

    // js中使用{}进行分组,同一个{}中的代码要么都执行,要么都不执行
    // 一个{}叫做一个代码块
    // {}只有分组的作用,没有其他的作用 没有作用域?
// prompt() 返回值是string类型 可以弹出一个提示框，该提示框中会带有一个文本框，用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数，该字符串会作为文本框的提示文字
    // 使用
        // var a=prompt("输入你想提示的文字");
        // 想要返回number类型可以写成这样
            // var a=+prompt("输入你想提示的文字");
    // 新的一年希望哥哥万事如意身体健康挣好多好多钱然后都给我
// console.time("计时器名称");
// console.timeEnd("计时器名称");

// 循环
    // 可以为循环创建一个label，来标识当前的循环
    // label:循环语句
    // 使用break语句时，可以在break后跟着一个label
    // 这样break将会结束指定的循环，而不是最近的

// 对象(object)引用数据类型 是一种复合数据类型，在对象中可以保存多个不同数据类型的属性
    // 对象的分类
    // 1.内建对象，由es表标准中定义的对象，在任何的es实现中都可以使用
        // 比如：math、string 
    // 2.宿主对象
        // 由js的运行环境提供的对象，目前来讲主要是由浏览器提供的对象
            // 比如BOM DOM
    // 3.自定义对象
        // 由开发人员自己创建的对象
        // 创建对象
            // 使用new关键字调用的函数是构造函数constructor 构造函数是专门用来创建对象的
            // var obj=new Object();
            // 在对象中保存的值称为属性
            // 向对象中添加属性
                // 语法：对象.属性名=属性值
                // Obj.name="tom";
            // 读取对象中的属性
                // 语法 对象.属性名；
                // 如果读取对象中没有的属性，不会报错而是会返回undefined
                // console.log(obj.name);
            // 修改对象属性值
                // 语法：对象.属性名=新属性值
            // 删除对象的属性
                // 语法:delete 对象.属性名
            // 属性名 尽量按照标识符规范  如果要使用特殊的属性名不能采用.的方式来操作
                // 语法 对象["属性名"]=属性值;
                // 读取方法 console.log(obj["属性名"]);
                // 使用[]这种形式去操作属性,更加的灵活
                // 在[]中可以直接传递一个变量,这样变量值是多少就会读取哪个属性
            // 属性值
                // js对象的属性值,可以是任意的数据类型
                // 甚至可以是一个对象
            // in运算符 
                // 通过该运算符可以检查一个对象中是否含有指定的属性
                    // 有true 无false
                // 语法:"属性名"in对象
// 引用数据类型
    // 基本数据类型 String Number Boolean null undefined
    // JS中变量都是保存在栈内存中的
        // 基本数据类型的值直接在栈内存中存储
        // 值与值之间是独立存在的,修改一个变量不会影响到其他的变量
    // 引用数据类型 Object
        // 对象是保存至对内存的,每创建一个新的对象,就会在堆内存中开辟出一个新的空间
        // 而变量保存的是对象的内存地址(对象的引用),如果两个变量保存的是同一个对象的引用,当一个对象通过一个变量修改属性时,另一个也会受到影响
    // 基本数据类型作比较时,比较的是值
    // 引用数据类型比较时,比较的是内存地址
// 对象字面量
    // 创建对象 var obj={};
    // 可以创建对象时,直接指定对象中的属性
    // 语法: var obj={name:"rr",age=28};
        // 对象字面量的属性名如果起的不符合命名规范需要加""
// 函数 也是一个对象
    // 函数中可以封装功能(代码),必要时可以执行功能
    //  创建一个函数对象
        // 可以将要封装的代码以字符串的形式传递给构造参数
        // 很少使用构造函数来创建
        // var fun=new Function("console.log("hello")");
        // 封装带函数的代码不会立即执行
        // 会在被调用的时候执行
        // 调用函数 语法:函数对象();
        // fun()
    // 使用函数声明创建一个函数
        // 语法:function 函数名([形参1,形参2]){
        //      语句..
        // }
    // 使用函数表达式创建一个函数
        // var fun3=function(){console.log("11")}
// 形参
    // 可以在函数的()中来指定一个或多个形参
    // 多个形参之间用,隔开声明形参就相当于在函数的内声明了对应的变量,但是不赋值
    // 赋值
        // 在调用函数时,可以在()中指定实参,实参会赋值给对应的形参
            // 实参可以是任意的数据类型
        // 调用函数时解析器不会检查实参的类型和数量 多余的形参不会被赋值
            // 如果实参的数量少于形参的数量,则没有对应实参的形参是undefined;
// 返回值
    // 可以使用return来设置函数的返回值
    // 语法: return 值
    // return后的值将会作为函数的执行结果返回,可以定义一个变量接收结果
    // function sum(a,b,c){
    //     var d = a+b+c;
    //     return d;
    // }
    // var result=sum(1,2,3);
    // return后的语句不会被执行
    // 如果return语句后不跟任何值或者函数中没有return就相当于返回一个undefined
// 实参可以是任何值
    // mianji()
        // 调用函数 相当于使用函数的返回值
    // mianji
        // 函数对象 相当于直接使用函数对象
// 立即执行函数
    // (function(){
    //     alert("我是匿名函数,我被立即执行了");
    // })();
    // 特点:一般只会执行一次
// 立即执行函数
// (function(){
//     alert("我是匿名函数,我被立即执行了");
// })();
// 特点:一般只会执行一次
// 函数也可以成为对象的属性,如果一个函数作为一个对象的属性保存,那么我们成这个函数是这个对象的方法,调用这个函数就说调用对象的方法
// var obj = { name: "rr", age: 12 }
// obj.sayName = function () {
//     console.log(obj.name);
// }
// // 调用方法
// obj.sayName();
// function fun() {
//     console.log(obj.sayName);
// }
// // 调用函数
// fun();
//枚举对象中的属性
// 使用for.. in语句在对象中有几个属性,循环就会执行几次
// 每次执行时,会将对象中的一个属性的名字赋值给变量
// for (var n in document) {
//     console.log("属性值" + obj[n]);
// }
// 作用域 指一个变量的作用范围
// js中一共有两种作用域
    // 1.全局作用域
        // 直接编写在script标签中的js代码,都是全局作用域;
        // 全局作用域在页面打开时创建,在页面关闭时销毁
        // 在全局作用域中有一个全局对象window,可以直接使用
            // window代表的是一个浏览器的窗口, 它由浏览器创建
        // 在全局作用域中,创建的对象都是会作为window对象的属性保存
            // var a=10; console.log(window.a);
        // 创建的函数都会作为window的方法
        // 变量的声明提前
            // 使用var关键字声明的变量,会在所有代码执行之前被声明
            // 但是如果声明变量时不使用var关键字,则变量不会被提前声明
        // 函数的声明提前
            // 使用函数声明形式创建的函数function 函数名(){}
                // 它会在所有代码执行之前就被创建,所以我们可以在函数声明前就调用函数
            // 使用函数表达式创建的函数var fun=functionion(){},不会被声明提前,所以不能在声明前调用
    // 2.函数作用域
        // 调用函数时创建,函数执行完毕后,函数作用域销毁
        // 每调用一次函数作用域就会创建一个新的函数作用域,他们之间相互独立
        // 在函数作用域中能访问到全局变量,在全局作用域中,无法访问函数作用域
        // 当在函数作用域操作一个变量是,它会先在自身作用域中寻找;没有就向上一级寻找,直到全局作用域
            // 如果全局作用域还没有,报错undefined
        // 在函数中想访问全局变量可以加window
        // 函数作用域遵循变量和函数声明提前的特性
        // 在函数中,不使用var声明的变量都会成为全局变量